/********************************************************************************* 
* Ephesoft is a Intelligent Document Capture and Mailroom Automation program 
* developed by Ephesoft, Inc. Copyright (C) 2010-2011 Ephesoft Inc. 
* 
* This program is free software; you can redistribute it and/or modify it under 
* the terms of the GNU Affero General Public License version 3 as published by the 
* Free Software Foundation with the addition of the following permission added 
* to Section 15 as permitted in Section 7(a): FOR ANY PART OF THE COVERED WORK 
* IN WHICH THE COPYRIGHT IS OWNED BY EPHESOFT, EPHESOFT DISCLAIMS THE WARRANTY 
* OF NON INFRINGEMENT OF THIRD PARTY RIGHTS. 
* 
* This program is distributed in the hope that it will be useful, but WITHOUT 
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
* FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more 
* details. 
* 
* You should have received a copy of the GNU Affero General Public License along with 
* this program; if not, see http://www.gnu.org/licenses or write to the Free 
* Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 
* 02110-1301 USA. 
* 
* You can contact Ephesoft, Inc. headquarters at 111 Academy Way, 
* Irvine, CA 92617, USA. or at email address info@ephesoft.com. 
* 
* The interactive user interfaces in modified source and object code versions 
* of this program must display Appropriate Legal Notices, as required under 
* Section 5 of the GNU Affero General Public License version 3. 
* 
* In accordance with Section 7(b) of the GNU Affero General Public License version 3, 
* these Appropriate Legal Notices must retain the display of the "Ephesoft" logo. 
* If the display of the logo is not reasonably feasible for 
* technical reasons, the Appropriate Legal Notices must display the words 
* "Powered by Ephesoft". 
********************************************************************************/ 

/********************************************************************************* 
* Ephesoft is a Intelligent Document Capture and Mailroom Automation program 
* developed by Ephesoft, Inc. Copyright (C) 2010-2011 Ephesoft Inc. 
* 
* This program is free software; you can redistribute it and/or modify it under 
* the terms of the GNU Affero General Public License version 3 as published by the 
* Free Software Foundation with the addition of the following permission added 
* to Section 15 as permitted in Section 7(a): FOR ANY PART OF THE COVERED WORK 
* IN WHICH THE COPYRIGHT IS OWNED BY EPHESOFT, EPHESOFT DISCLAIMS THE WARRANTY 
* OF NON INFRINGEMENT OF THIRD PARTY RIGHTS. 
* 
* This program is distributed in the hope that it will be useful, but WITHOUT 
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
* FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more 
* details. 
* 
* You should have received a copy of the GNU Affero General Public License along with 
* this program; if not, see http://www.gnu.org/licenses or write to the Free 
* Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 
* 02110-1301 USA. 
* 
* You can contact Ephesoft, Inc. headquarters at 111 Academy Way, 
* Irvine, CA 92617, USA. or at email address info@ephesoft.com. 
* 
* The interactive user interfaces in modified source and object code versions 
* of this program must display Appropriate Legal Notices, as required under 
* Section 5 of the GNU Affero General Public License version 3. 
* 
* In accordance with Section 7(b) of the GNU Affero General Public License version 3, 
* these Appropriate Legal Notices must retain the display of the "Ephesoft" logo. 
* If the display of the logo is not reasonably feasible for 
* technical reasons, the Appropriate Legal Notices must display the words 
* "Powered by Ephesoft". 
********************************************************************************/ 

/********************************************************************************* 
* Ephesoft is a Intelligent Document Capture and Mailroom Automation program 
* developed by Ephesoft, Inc. Copyright (C) 2010-2011 Ephesoft Inc. 
* 
* This program is free software; you can redistribute it and/or modify it under 
* the terms of the GNU Affero General Public License version 3 as published by the 
* Free Software Foundation with the addition of the following permission added 
* to Section 15 as permitted in Section 7(a): FOR ANY PART OF THE COVERED WORK 
* IN WHICH THE COPYRIGHT IS OWNED BY EPHESOFT, EPHESOFT DISCLAIMS THE WARRANTY 
* OF NON INFRINGEMENT OF THIRD PARTY RIGHTS. 
* 
* This program is distributed in the hope that it will be useful, but WITHOUT 
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
* FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more 
* details. 
* 
* You should have received a copy of the GNU Affero General Public License along with 
* this program; if not, see http://www.gnu.org/licenses or write to the Free 
* Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 
* 02110-1301 USA. 
* 
* You can contact Ephesoft, Inc. headquarters at 111 Academy Way, 
* Irvine, CA 92617, USA. or at email address info@ephesoft.com. 
* 
* The interactive user interfaces in modified source and object code versions 
* of this program must display Appropriate Legal Notices, as required under 
* Section 5 of the GNU Affero General Public License version 3. 
* 
* In accordance with Section 7(b) of the GNU Affero General Public License version 3, 
* these Appropriate Legal Notices must retain the display of the "Ephesoft" logo. 
* If the display of the logo is not reasonably feasible for 
* technical reasons, the Appropriate Legal Notices must display the words 
* "Powered by Ephesoft". 
********************************************************************************/ 

/********************************************************************************* 
* Ephesoft is a Intelligent Document Capture and Mailroom Automation program 
* developed by Ephesoft, Inc. Copyright (C) 2010-2011 Ephesoft Inc. 
* 
* This program is free software; you can redistribute it and/or modify it under 
* the terms of the GNU Affero General Public License version 3 as published by the 
* Free Software Foundation with the addition of the following permission added 
* to Section 15 as permitted in Section 7(a): FOR ANY PART OF THE COVERED WORK 
* IN WHICH THE COPYRIGHT IS OWNED BY EPHESOFT, EPHESOFT DISCLAIMS THE WARRANTY 
* OF NON INFRINGEMENT OF THIRD PARTY RIGHTS. 
* 
* This program is distributed in the hope that it will be useful, but WITHOUT 
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
* FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more 
* details. 
* 
* You should have received a copy of the GNU Affero General Public License along with 
* this program; if not, see http://www.gnu.org/licenses or write to the Free 
* Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 
* 02110-1301 USA. 
* 
* You can contact Ephesoft, Inc. headquarters at 111 Academy Way, 
* Irvine, CA 92617, USA. or at email address info@ephesoft.com. 
* 
* The interactive user interfaces in modified source and object code versions 
* of this program must display Appropriate Legal Notices, as required under 
* Section 5 of the GNU Affero General Public License version 3. 
* 
* In accordance with Section 7(b) of the GNU Affero General Public License version 3, 
* these Appropriate Legal Notices must retain the display of the "Ephesoft" logo. 
* If the display of the logo is not reasonably feasible for 
* technical reasons, the Appropriate Legal Notices must display the words 
* "Powered by Ephesoft". 
********************************************************************************/ 

package com.ephesoft.dcma.tableextraction;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

import com.ephesoft.dcma.batch.schema.Batch;
import com.ephesoft.dcma.batch.schema.Column;
import com.ephesoft.dcma.batch.schema.Coordinates;
import com.ephesoft.dcma.batch.schema.DataTable;
import com.ephesoft.dcma.batch.schema.DocField;
import com.ephesoft.dcma.batch.schema.Document;
import com.ephesoft.dcma.batch.schema.Field;
import com.ephesoft.dcma.batch.schema.HeaderRow;
import com.ephesoft.dcma.batch.schema.HocrPages;
import com.ephesoft.dcma.batch.schema.Page;
import com.ephesoft.dcma.batch.schema.Row;
import com.ephesoft.dcma.batch.schema.DataTable.Rows;
import com.ephesoft.dcma.batch.schema.Document.DataTables;
import com.ephesoft.dcma.batch.schema.Document.DocumentLevelFields;
import com.ephesoft.dcma.batch.schema.Field.CoordinatesList;
import com.ephesoft.dcma.batch.schema.HocrPages.HocrPage;
import com.ephesoft.dcma.batch.schema.HocrPages.HocrPage.Spans;
import com.ephesoft.dcma.batch.schema.HocrPages.HocrPage.Spans.Span;
import com.ephesoft.dcma.batch.service.BatchSchemaService;
import com.ephesoft.dcma.batch.service.PluginPropertiesService;
import com.ephesoft.dcma.core.exception.DCMAApplicationException;
import com.ephesoft.dcma.da.domain.TableColumnsInfo;
import com.ephesoft.dcma.da.domain.TableInfo;
import com.ephesoft.dcma.da.service.TableInfoService;
import com.ephesoft.dcma.tableextraction.constant.TableExtractionConstants;
import com.ephesoft.dcma.tableextraction.util.DataCarrier;
import com.ephesoft.dcma.tableextraction.util.LineDataCarrier;
import com.ephesoft.dcma.tablefinder.service.TableFinderService;

/**
 * This class is responsible to extract table grid data from the hOCR files(html files with HOCR text) from image files. Service will
 * read all the pages one by one and search some pattern corresponding to document type and update the batch xml file with data tables
 * values.
 * 
 * @author Ephesoft
 * @version 1.0
 * @see com.ephesoft.dcma.tableextraction.service.TableExtractionService
 * 
 */
@Component
public class TableExtraction {

	/**
	 * LOGGER to print the logging information.
	 */
	private static final Logger LOGGER = LoggerFactory.getLogger(TableExtraction.class);

	private static final String TABLE_EXTRACTION_PLUGIN = "TABLE_EXTRACTION";

	/**
	 * Reference of BatchSchemaService.
	 */
	@Autowired
	private BatchSchemaService batchSchemaService;

	/**
	 * Reference of TableInfoService.
	 */
	@Autowired
	private TableInfoService tableInfoService;

	/**
	 * Reference of TableFinderService.
	 */
	@Autowired
	private TableFinderService tableFinderService;

	@Autowired
	@Qualifier("batchInstancePluginPropertiesService")
	private PluginPropertiesService pluginPropertiesService;

	// TODO remove
	// @Autowired
	// private TableColumnsInfoService tableColumnsInfoService;
	// TODO remove
	/**
	 * Confidence score.
	 */
	private String confidenceScore;

	/**
	 * @return the confidenceScore
	 */
	public final String getConfidenceScore() {
		return confidenceScore;
	}

	/**
	 * @param confidenceScore the confidenceScore to set
	 */
	public final void setConfidenceScore(final String confidenceScore) {
		this.confidenceScore = confidenceScore;
	}

	/**
	 * Width of line.
	 */
	private String widthOfLine;

	/**
	 * @return the widthOfLine
	 */
	public String getWidthOfLine() {
		return widthOfLine;
	}

	/**
	 * @param widthOfLine the widthOfLine to set
	 */
	public void setWidthOfLine(String widthOfLine) {
		this.widthOfLine = widthOfLine;
	}

	/**
	 * This method is used to extract the document level fields using key value based extraction. Update the extracted data to the
	 * batch.xml file.
	 * 
	 * @param batchInstanceIdentifier String
	 * @return isSuccessful boolean
	 * @throws DCMAApplicationException Check for all the input parameters.
	 */
	public final boolean extractFields(final String batchInstanceIdentifier) throws DCMAApplicationException {
		String switchValue = pluginPropertiesService.getPropertyValue(batchInstanceIdentifier, TABLE_EXTRACTION_PLUGIN,
				TableExtractionProperties.TABLE_EXTRACTION_SWITCH);
		if (("ON").equals(switchValue)) {
			String errMsg = null;
			if (tableFinderService == null) {
				errMsg = "No instance of TableFinderServiceImpl.";
				LOGGER.error(errMsg);
				throw new DCMAApplicationException(errMsg);
			}
			setWidthOfLine(tableFinderService.getWidthOfLine());
			setConfidenceScore(tableFinderService.getConfidenceScore());

			if (null == batchInstanceIdentifier) {
				errMsg = "Invalid batchInstanceId.";
				LOGGER.error(errMsg);
				throw new DCMAApplicationException(errMsg);
			}

			LOGGER.info("batchInstanceIdentifier : " + batchInstanceIdentifier);

			final Batch batch = batchSchemaService.getBatch(batchInstanceIdentifier);

			boolean isSuccessful = false;
			try {
				final List<Document> docTypeList = batch.getDocuments().getDocument();

				if (null == docTypeList) {
					LOGGER.info("In valid batch documents.");
				} else {
					isSuccessful = processDocPage(docTypeList, batchInstanceIdentifier, batch);
				}
			} catch (DCMAApplicationException e) {
				LOGGER.error(e.getMessage());
				throw new DCMAApplicationException(e.getMessage(), e);
			} catch (Exception e) {
				LOGGER.error(e.getMessage());
				throw new DCMAApplicationException(e.getMessage(), e);
			}

			batchSchemaService.updateBatch(batch);

			return isSuccessful;
		} else {
			LOGGER.info("Skipping Table extraction. Switch set as off.");
			return true;
		}
	}

	/**
	 * This method will process for each page for each document.
	 * 
	 * @param xmlDocuments List<DocumentType>
	 * @param batchInstanceIdentifier String
	 * @param batch Batch
	 * @return isSuccessful
	 * @throws DCMAApplicationException Check for all the input parameters.
	 */
	private boolean processDocPage(final List<Document> xmlDocuments, final String batchInstanceIdentifier, final Batch batch)
			throws DCMAApplicationException {

		boolean isSuccessful = false;
		if (null == xmlDocuments || xmlDocuments.isEmpty()) {
			throw new DCMAApplicationException("In valid parameters.");
		}

		DataCarrier startDataCarrier = null;
		List<LineDataCarrier> lineDataCarrierList = null;
		for (Document document : xmlDocuments) {
			// Create doc level fields for document.
			createDocLevelFields(document, batchInstanceIdentifier);

			startDataCarrier = null;
			if (null == document) {
				continue;
			}

			final String docTypeNameBatch = document.getType();
			if (null == docTypeNameBatch || docTypeNameBatch.isEmpty()) {
				continue;
			}

			final List<Page> pageList = document.getPages().getPage();
			if (null == pageList || pageList.isEmpty()) {
				continue;
			}

			String batchClassIdentifier = batch.getBatchClassIdentifier();

			if (null == batchClassIdentifier || batchClassIdentifier.isEmpty()) {
				throw new DCMAApplicationException("Batch class identifier is null or empty...");
			}

			List<TableInfo> tableInfoList = tableInfoService.getTableInfoByDocTypeName(docTypeNameBatch, batchClassIdentifier);

			if (null == tableInfoList || tableInfoList.isEmpty()) {
				LOGGER.info("Table info list is null or empty.");
				continue;
			}

			DataTables dataTables = document.getDataTables();
			if (null == dataTables) {
				dataTables = new DataTables();
				document.setDataTables(dataTables);
			}

			List<DataTable> dataTableList = dataTables.getDataTable();

			startDataCarrier = readAllDataTables(tableInfoList, startDataCarrier, lineDataCarrierList, dataTableList, pageList,
					batchInstanceIdentifier);

		}

		return isSuccessful;
	}

	/**
	 * readAllDataTables.
	 * 
	 * @param tableInfoList
	 * @param startDataCarrier
	 * @param lineDataCarrierList
	 * @param dataTableList
	 * @param pageList
	 * @return
	 * @throws DCMAApplicationException
	 */
	private DataCarrier readAllDataTables(final List<TableInfo> tableInfoList, DataCarrier startDataCarrier,
			List<LineDataCarrier> lineDataCarrierList, final List<DataTable> dataTableList, final List<Page> pageList,
			final String batchInstanceIdentifier) throws DCMAApplicationException {

		for (TableInfo tableInfo : tableInfoList) {
			if (null == tableInfo) {
				LOGGER.info("Table info is null.");
				continue;
			}

			lineDataCarrierList = new ArrayList<LineDataCarrier>();

			final String tableName = tableInfo.getName();
			final String startPattern = tableInfo.getStartPattern();
			final String endPattern = tableInfo.getEndPattern();

			if (null == tableName || tableName.isEmpty()) {
				throw new DCMAApplicationException("Table name is null or empty.");
			}

			if (null == startPattern || startPattern.isEmpty()) {
				throw new DCMAApplicationException("Table start pattern is null or empty.");
			}

			if (null == endPattern || endPattern.isEmpty()) {
				throw new DCMAApplicationException("Table end pattern is null or empty.");
			}

			DataTable dataTable = new DataTable();
			dataTable.setName(tableName);
			dataTableList.add(dataTable);

			HeaderRow headerRow = dataTable.getHeaderRow();
			if (null == headerRow) {
				headerRow = new HeaderRow();
				dataTable.setHeaderRow(headerRow);
			}
			HeaderRow.Columns columnsHeader = headerRow.getColumns();
			if (null == columnsHeader) {
				columnsHeader = new HeaderRow.Columns();
				headerRow.setColumns(columnsHeader);
			}
			List<Column> columnHeaderList = columnsHeader.getColumn();

			List<TableColumnsInfo> tableColumnsInfoList = tableInfo.getTableColumnsInfo();

			// TODO remove
			// List<TableColumnsInfo> tableColumnsInfoList = tableColumnsInfoService.getTableColumnsInfoByTableInfo(tableInfo);
			// TODO remove

			if (null == tableColumnsInfoList || tableColumnsInfoList.isEmpty()) {
				LOGGER.error("TableColumnsInfo list is null or empty.");
				continue;
			}

			Rows rows = dataTable.getRows();
			if (null == rows) {
				rows = new Rows();
				dataTable.setRows(rows);
			}

			List<Row> rowList = rows.getRow();

			for (TableColumnsInfo tableColumnsInfo : tableColumnsInfoList) {
				// Create the table header first and then all the columns for the header.
				Column column = new Column();
				String nameOfColumn = tableColumnsInfo.getColumnName();
				column.setName(nameOfColumn);
				columnHeaderList.add(column);
			}

			startDataCarrier = searchAllRowOfTables(pageList, lineDataCarrierList, startDataCarrier, startPattern, endPattern,
					batchInstanceIdentifier);

			startDataCarrier = addDataTablesValues(lineDataCarrierList, tableColumnsInfoList, rowList, startDataCarrier);
		}

		return startDataCarrier;
	}

	/**
	 * addDataTablesValues.
	 * 
	 * @param lineDataCarrierList
	 * @param tableColumnsInfoList
	 * @param rowList
	 * @param startDataCarrier
	 * @return
	 * @throws DCMAApplicationException
	 */
	private DataCarrier addDataTablesValues(final List<LineDataCarrier> lineDataCarrierList,
			final List<TableColumnsInfo> tableColumnsInfoList, final List<Row> rowList, DataCarrier startDataCarrier)
			throws DCMAApplicationException {
		boolean isRowAvaliable = false;
		boolean isRowValidForAllMandatoryColumns = true;
		// int index = 0;
		// for (index = 0; index < tableColumnsInfoList.size(); index++) {
		// alternateFields.add(new ArrayList<Field>());
		// }
		for (LineDataCarrier lineDataCarrier : lineDataCarrierList) {
			String pageID = lineDataCarrier.getPageID();
			String rowData = lineDataCarrier.getLineRowData();

			isRowValidForAllMandatoryColumns = true;
			Row row = new Row();
			Row.Columns columnsRow = row.getColumns();

			if (null == columnsRow) {
				columnsRow = new Row.Columns();
				row.setColumns(columnsRow);
			}

			row.setRowCoordinates(lineDataCarrier.getRowCoordinates());

			List<Column> columnRowList = columnsRow.getColumn();

			isRowAvaliable = false;
			// index = 0;
			for (TableColumnsInfo tableColumnsInfo : tableColumnsInfoList) {

				// Search for all the table row data one by one.
				String patternOfColumnData = tableColumnsInfo.getColumnPattern();
				String betweenLeft = tableColumnsInfo.getBetweenLeft();
				String betweenRight = tableColumnsInfo.getBetweenRight();
				boolean isRequired = tableColumnsInfo.isRequired();

				List<String> outputList = findPattern(rowData, patternOfColumnData);
				Column column = new Column();
				Column.AlternateValues alternateValues = new Column.AlternateValues();
				if (null == outputList || outputList.isEmpty()) {

					column.setName(null);
					column.setValue(null);
					column.setConfidence(0);
					column.setCoordinatesList(null);
					column.setPage(pageID);
					column.setValid(false);
					column.setAlternateValues(alternateValues);
					columnRowList.add(column);
				} else {

					column.setName(null);
					column.setConfidence(100);
					column.setPage(pageID);
					column.setValid(false);
					column.setCoordinatesList(new CoordinatesList());
					column.setAlternateValues(alternateValues);
					columnRowList.add(column);
					isRowAvaliable = true;
					Set<String> alternateValueSet = new HashSet<String>();
					boolean isFound = false;
					outerLoop: for (String output : outputList) {
						if (output == null) {
							if (!isFound) {
								column.setValue(TableExtractionConstants.EMPTY);
							}
							continue;
						}
						if (!isFound) {
							column.setValue(output);
						}

						List<Integer> outputIndexList = getIndexList(output, lineDataCarrier);
						// List<Integer> indexList = lineDataCarrier.getIndexOfSpan(output);
						// String[] foundValArr = output.split(TableExtractionConstants.SPACE);

						// List<Integer> indexList = lineDataCarrier.getIndexOfSpan(output);
						if (outputIndexList == null || outputIndexList.isEmpty()) {
							continue;
						}
						// validate the field with left right.
						// Check the validation of data.
						if (!alternateValueSet.contains(output)) {
							alternateValueSet.add(output);
							// for (Integer currentIndex : indexList) {
							for (Integer currentIndex = 0; currentIndex < outputIndexList.size(); currentIndex = currentIndex
									+ output.split(TableExtractionConstants.SPACE).length) {
								int localIndex = currentIndex;
								Field alternateValue = new Field();
								alternateValue.setValue(output);
								alternateValue.setName(null);
								alternateValue.setConfidence(100);
								alternateValue.setPage(pageID);
								CoordinatesList coordinatesList = new CoordinatesList();
								alternateValue.setCoordinatesList(coordinatesList);
								while (localIndex < currentIndex + output.split(TableExtractionConstants.SPACE).length
										&& localIndex < outputIndexList.size()) {
									Span currentSpan = lineDataCarrier.getCurrentSpan(outputIndexList.get(localIndex));
									if (null != currentSpan) {
										Coordinates coordinates = new Coordinates();
										Coordinates hocrCoordinates = currentSpan.getCoordinates();
										if (null != hocrCoordinates) {
											coordinates.setX0(hocrCoordinates.getX0());
											coordinates.setX1(hocrCoordinates.getX1());
											coordinates.setY0(hocrCoordinates.getY0());
											coordinates.setY1(hocrCoordinates.getY1());
											alternateValue.getCoordinatesList().getCoordinates().add(coordinates);
										}
									}
									localIndex++;
								}
								column.getAlternateValues().getAlternateValue().add(alternateValue);
							}
						}
						if (isFound) {
							continue;
						}

						if (betweenLeft != null && !betweenLeft.isEmpty()) {
							if (betweenRight != null && !betweenRight.isEmpty()) {
								for (Integer currentIndex = 0; currentIndex < outputIndexList.size(); currentIndex = currentIndex
										+ output.split(TableExtractionConstants.SPACE).length) {
									Integer localIndex = currentIndex;
									column.getCoordinatesList().getCoordinates().clear();
									while (localIndex < currentIndex + output.split(TableExtractionConstants.SPACE).length
											&& localIndex < outputIndexList.size()) {
										column.setValue(output);
										Span currentSpan = lineDataCarrier.getCurrentSpan(outputIndexList.get(localIndex));
										if (null != currentSpan) {
											setColumnCoordinates(currentSpan, column);
										}
										localIndex++;
									}
									Span leftSpan = lineDataCarrier.getLeftSpan(outputIndexList.get(currentIndex));
									if (null == leftSpan) {
										LOGGER.info("Left Span is null. betweenLeft = " + betweenLeft);
										continue;
									}
									Span rightSpan = lineDataCarrier.getRightSpan(outputIndexList.get(localIndex - 1));
									if (null == rightSpan) {
										LOGGER.info("Right Span is null. betweenRight = " + betweenRight);
										continue;
									}
									DataCarrier leftDataCarrier = findPattern(leftSpan, betweenLeft);
									DataCarrier rightDataCarrier = findPattern(rightSpan, betweenRight);
									if (null != leftDataCarrier && null != rightDataCarrier) {
										column.setValid(true);
										isFound = true;
										continue outerLoop;
										// continue;
										// break outerLoop;
									}
								}
							} else {
								for (Integer currentIndex = 0; currentIndex < outputIndexList.size(); currentIndex = currentIndex
										+ output.split(TableExtractionConstants.SPACE).length) {
									Integer localIndex = currentIndex;
									column.setValue(output);
									column.getCoordinatesList().getCoordinates().clear();
									while (localIndex < currentIndex + output.split(TableExtractionConstants.SPACE).length
											&& localIndex < outputIndexList.size()) {
										column.setValue(output);
										Span currentSpan = lineDataCarrier.getCurrentSpan(outputIndexList.get(localIndex));
										if (null != currentSpan) {
											setColumnCoordinates(currentSpan, column);
										}
										localIndex++;
									}
									Span leftSpan = lineDataCarrier.getLeftSpan(outputIndexList.get(currentIndex));
									if (null == leftSpan) {
										LOGGER.info("Left Span is null. betweenLeft = " + betweenLeft);
										continue;
									}
									DataCarrier leftDataCarrier = findPattern(leftSpan, betweenLeft);
									if (null != leftDataCarrier) {
										column.setValid(true);
										isFound = true;
										continue outerLoop;
										// break outerLoop;
									}
								}
							}
						} else {
							if (betweenRight != null && !betweenRight.isEmpty()) {
								for (Integer currentIndex = 0; currentIndex < outputIndexList.size(); currentIndex = currentIndex
										+ output.split(TableExtractionConstants.SPACE).length) {
									Integer localIndex = currentIndex;
									column.setValue(output);
									column.getCoordinatesList().getCoordinates().clear();
									while (localIndex < currentIndex + output.split(TableExtractionConstants.SPACE).length
											&& localIndex < outputIndexList.size()) {
										column.setValue(output);
										Span currentSpan = lineDataCarrier.getCurrentSpan(outputIndexList.get(localIndex));
										if (null != currentSpan) {
											setColumnCoordinates(currentSpan, column);
										}
										localIndex++;
									}
									Span rightSpan = lineDataCarrier.getRightSpan(outputIndexList.get(localIndex - 1));
									if (null == rightSpan) {
										LOGGER.info("Right Span is null. betweenRight = " + betweenRight);
										continue;
									}
									DataCarrier rightDataCarrier = findPattern(rightSpan, betweenRight);
									if (null != rightDataCarrier) {
										column.setValid(true);
										isFound = true;
										continue outerLoop;
										// break outerLoop;
									}
								}
							} else {
								column.setValue(output);
								column.setValid(true);
								Span currentSpan = lineDataCarrier.getCurrentSpan(0);
								column.getCoordinatesList().getCoordinates().clear();
								if (null != currentSpan) {
									setColumnCoordinates(currentSpan, column);
								}
							}
						}
					}
				}

				// Checking if row contains valid data for every mandatory column
				if (isRequired && !column.isValid()) {
					isRowValidForAllMandatoryColumns = false;
				}
				// index++;
			}

			if (isRowAvaliable && isRowValidForAllMandatoryColumns) {
				LOGGER.info("Row data : " + rowData);
				rowList.add(row);
				startDataCarrier = null;
			}

		}

		// setAlternateValues(rowList, alternateFields);

		return startDataCarrier;
	}

	/**
	 * This method returns the list of indexes of matches of string in a row.
	 * 
	 * @param output {@link String}
	 * @param lineDataCarrier {@link LineDataCarrier}
	 * @return
	 */
	private List<Integer> getIndexList(final String output, final LineDataCarrier lineDataCarrier) {
		String[] foundValArr = output.split(TableExtractionConstants.SPACE);
		List<Coordinates> coordinateList = new ArrayList<Coordinates>();
		List<Integer> outputIndexList = new ArrayList<Integer>();
		if (null != foundValArr && foundValArr.length >= 0) {
			String firstKeyValue = foundValArr[0];
			List<Integer> indexList = lineDataCarrier.getIndexOfSpan(firstKeyValue);
			if (null != indexList) {
				List<Span> spanList = lineDataCarrier.getSpanList();
				for (Integer integer : indexList) {
					List<Coordinates> local = new ArrayList<Coordinates>();
					List<Integer> localIndexList = new ArrayList<Integer>();
					for (int p = 0; p < foundValArr.length; p++) {
						if (integer < spanList.size()) {
							Span span = spanList.get(integer);
							if (null == span) {
								continue;
							}
							String value = span.getValue();
							if (null == value) {
								continue;
							}
							// integer++;
							String foundVal = foundValArr[p];
							if (value.contains(foundVal)) {
								localIndexList.add(integer);
								local.add(span.getCoordinates());
							}
							integer++;
						}
					}
					if (local.size() == foundValArr.length) {
						outputIndexList.addAll(localIndexList);
						coordinateList.addAll(local);
					}
				}
			}
		}
		return outputIndexList;
	}

	/**
	 * This method adds the coordinates of current span to the coordinates list of a column.
	 * 
	 * @param currentSpan
	 * @param column
	 */
	private void setColumnCoordinates(final Span currentSpan, final Column column) {
		if (null != currentSpan) {
			Coordinates coordinates = new Coordinates();
			Coordinates hocrCoordinates = currentSpan.getCoordinates();
			if (null != hocrCoordinates) {
				coordinates.setX0(hocrCoordinates.getX0());
				coordinates.setX1(hocrCoordinates.getX1());
				coordinates.setY0(hocrCoordinates.getY0());
				coordinates.setY1(hocrCoordinates.getY1());
				// column.getCoordinatesList().getCoordinates().clear();
				column.getCoordinatesList().getCoordinates().add(coordinates);
				// column.setCoordinates(coordinates);
			}
		}
	}

	/**
	 * searchAllRowOfTables.
	 * 
	 * @param pageList
	 * @param lineDataCarrierList
	 * @param startDataCarrier
	 * @param startPattern
	 * @param endPattern
	 * @return
	 * @throws DCMAApplicationException
	 */
	private DataCarrier searchAllRowOfTables(final List<Page> pageList, final List<LineDataCarrier> lineDataCarrierList,
			DataCarrier startDataCarrier, final String startPattern, final String endPattern, final String batchInstanceIdentifier)
			throws DCMAApplicationException {

		String errMsg = null;
		pageLabel: for (Page pageType : pageList) {

			final String pageID = pageType.getIdentifier();

			final HocrPages hocrPages = batchSchemaService.getHocrPages(batchInstanceIdentifier, pageID);

			if (null == hocrPages) {
				throw new DCMAApplicationException("No Hocr files found for page id : " + pageID);
			}

			final List<HocrPage> hocrPageList = hocrPages.getHocrPage();

			HocrPage hocrPage = hocrPageList.get(0);

			if (pageType.getIdentifier().equals(pageID)) {

				LOGGER.info("HocrPage page ID : " + pageID);
				final Spans spans = hocrPage.getSpans();

				LineDataCarrier lineDataCarrier = new LineDataCarrier(pageID);
				lineDataCarrierList.add(lineDataCarrier);

				if (null != spans) {

					List<Span> linkedList = getSortedList(spans);
					if (null == linkedList || linkedList.isEmpty()) {
						LOGGER.info("Return linked list is null for the page id = " + pageID);
						continue;
					}
					ListIterator<Span> listItr = linkedList.listIterator();
					if (null == listItr) {
						LOGGER.info("Return list iterator is null for the page id = " + pageID);
						continue;
					}
					// int nextIndex = -1;

					if (startDataCarrier == null) {
						while (listItr.hasNext()) {
							final Span span = listItr.next();
							try {
								startDataCarrier = findPattern(span, startPattern);
								if (null != startDataCarrier) {
									// nextIndex = listItr.nextIndex();
									LOGGER.info("Start pattern found for table where start pattern : " + startPattern);
									break;
								} else {
									LOGGER.info("No start pattern found for table where start pattern : " + startPattern);

								}
							} catch (Exception e) {
								errMsg = e.getMessage();
								LOGGER.error(errMsg, e);
							}
						}
					}
					if (startDataCarrier != null) {
						// if (nextIndex != -1) {
						// listItr = linkedList.listIterator(nextIndex);
						// }
						while (listItr.hasNext()) {
							final Span span = listItr.next();
							DataCarrier endDataCarrier = findPattern(span, endPattern);
							if (null != endDataCarrier) {
								LOGGER.info("End pattern found for table where end pattern : " + endPattern);
								// continue documentLabel;
								break pageLabel;
							} else {
								// TODO add code to search table content.
								// get the line array as word by word
								// fetch from db all the columns and patterns.
								// validate using left and right pattern.
								List<Span> spanList = lineDataCarrier.getSpanList();
								if (spanList.isEmpty()) {
									spanList.add(span);
								} else {
									Span lastSpan = spanList.get(spanList.size() - 1);
									int compare = lastSpan.getCoordinates().getY1().intValue()
											- span.getCoordinates().getY1().intValue();
									int defaultValue = 20;
									try {
										defaultValue = Integer.parseInt(getWidthOfLine());
									} catch (NumberFormatException nfe) {
										LOGGER.error(nfe.getMessage(), nfe);
										defaultValue = 20;
									}
									if (compare >= -defaultValue && compare <= defaultValue) {
										spanList.add(span);
									} else {
										lineDataCarrier = new LineDataCarrier(pageID);
										lineDataCarrierList.add(lineDataCarrier);
										spanList = lineDataCarrier.getSpanList();
										spanList.add(span);
									}
								}
							}
						}
					}
				}
			}
		}

		return startDataCarrier;
	}

	/**
	 * Method is responsible for finding the patterns and returned the found data List.
	 * 
	 * @param span Span
	 * @param patternStr String
	 * @return DataCarrier
	 * @throws DCMAApplicationException Check for all the input parameters and find the pattern.
	 */
	private final DataCarrier findPattern(final Span span, final String patternStr) throws DCMAApplicationException {

		String errMsg = null;
		DataCarrier dataCarrier = null;
		final CharSequence inputStr = span.getValue();
		boolean isFound = false;
		if (null == inputStr || TableExtractionConstants.EMPTY.equals(inputStr)) {

			errMsg = "Invalid input character sequence.";
			// throw new DCMAApplicationException(errMsg);
			LOGGER.info(errMsg);

		} else {

			if (null == patternStr || TableExtractionConstants.EMPTY.equals(patternStr)) {
				errMsg = "Invalid input pattern sequence.";
				throw new DCMAApplicationException(errMsg);
			}

			// Compile and use regular
			// expression
			final Pattern pattern = Pattern.compile(patternStr);
			final Matcher matcher = pattern.matcher(inputStr);
			// boolean matchFound = matcher.find();
			while (matcher.find()) {
				// Get all groups for this match
				for (int i = 0; i <= matcher.groupCount(); i++) {
					final String groupStr = matcher.group(i);
					isFound = false;
					if (patternStr.contains(TableExtractionConstants.NOT_SPACE)) {
						if (groupStr.contains(TableExtractionConstants.FULL_STOP)) {
							isFound = true;
						}
					} else {
						isFound = true;
					}

					if (isFound) {
						int confidenceInt = 100;
						try {
							confidenceInt = Integer.parseInt(getConfidenceScore());
						} catch (NumberFormatException nfe) {
							LOGGER.error(nfe.getMessage(), nfe);
						}
						final float confidence = (groupStr.length() * confidenceInt) / inputStr.length();
						dataCarrier = new DataCarrier(span, confidence, groupStr);
						LOGGER.info(groupStr);
					}
				}
			}
		}

		return dataCarrier;
	}

	/**
	 * Method is responsible for finding the patterns and returned the found data List.
	 * 
	 * @param span Span
	 * @param patternStr String
	 * @return DataCarrier
	 * @throws DCMAApplicationException Check for all the input parameters and find the pattern.
	 */
	private final List<String> findPattern(final String value, final String patternStr) throws DCMAApplicationException {

		String errMsg = null;
		List<String> outputList = null;
		final CharSequence inputStr = value;
		boolean isFound = false;
		if (null == inputStr || TableExtractionConstants.EMPTY.equals(inputStr)) {

			errMsg = "Invalid input character sequence.";
			// throw new DCMAApplicationException(errMsg);
			LOGGER.info(errMsg);

		} else {

			if (null == patternStr || TableExtractionConstants.EMPTY.equals(patternStr)) {
				errMsg = "Invalid input pattern sequence.";
				throw new DCMAApplicationException(errMsg);
			}

			// Compile and use regular
			// expression
			final Pattern pattern = Pattern.compile(patternStr);
			final Matcher matcher = pattern.matcher(inputStr);
			// boolean matchFound = matcher.find();
			while (matcher.find()) {
				// Get all groups for this match
				for (int i = 0; i <= matcher.groupCount(); i++) {
					final String groupStr = matcher.group(i);
					isFound = false;
					if (groupStr != null) {
						if (patternStr.contains(TableExtractionConstants.NOT_SPACE)) {
							if (groupStr.contains(TableExtractionConstants.FULL_STOP)) {
								isFound = true;
							}
						} else {
							isFound = true;
						}
					}

					if (isFound) {
						if (null == outputList) {
							outputList = new ArrayList<String>();
						}
						outputList.add(groupStr);
						LOGGER.info(groupStr);
					}
				}
			}
		}

		return outputList;
	}

	private List<Span> getSortedList(final Spans spans) {

		final List<Span> spanList = spans.getSpan();
		int width = 20;
		try {
			width = Integer.parseInt(getWidthOfLine());
		} catch (NumberFormatException nfe) {
			LOGGER.error(nfe.getMessage(), nfe);
			width = 20;
		}
		final int defaultValue = width;
		// TODO optimize the set creation for document level fields.
		final Set<Span> set = new TreeSet<Span>(new Comparator<Span>() {

			public int compare(final Span firstSpan, final Span secSpan) {
				BigInteger s1Y1 = firstSpan.getCoordinates().getY1();
				BigInteger s2Y1 = secSpan.getCoordinates().getY1();
				int returnValue = 0;
				int compare = s1Y1.intValue() - s2Y1.intValue();
				if (compare >= -defaultValue && compare <= defaultValue) {
					BigInteger s1X1 = firstSpan.getCoordinates().getX1();
					BigInteger s2X1 = secSpan.getCoordinates().getX1();
					returnValue = s1X1.compareTo(s2X1);
				} else {
					returnValue = s1Y1.compareTo(s2Y1);
				}
				return returnValue;
			}
		});

		set.addAll(spanList);

		final List<Span> linkedList = new LinkedList<Span>();
		linkedList.addAll(set);

		// TODO add the clear method to remove all elements of set since it not required after adding it to linked list.
		// set.clear();

		return linkedList;

	}

	/**
	 * This method creates new document level fields for document if they haven't been created by previous plugins.
	 * 
	 * @param eachDocType
	 * @param batchInstanceIdentifier
	 */
	private void createDocLevelFields(Document eachDocType, String batchInstanceIdentifier) {
		DocumentLevelFields documentLevelFields = eachDocType.getDocumentLevelFields();
		if (documentLevelFields == null) {
			documentLevelFields = new DocumentLevelFields();
			eachDocType.setDocumentLevelFields(documentLevelFields);
		}
		List<DocField> docLevelFields = documentLevelFields.getDocumentLevelField();
		if (docLevelFields == null || docLevelFields.isEmpty()) {
			LOGGER.info("Getting document level fields for document type : " + eachDocType.getType());
			List<com.ephesoft.dcma.da.domain.FieldType> allFdTypes = pluginPropertiesService.getFieldTypes(batchInstanceIdentifier,
					eachDocType.getType());
			if (allFdTypes != null) {
				for (com.ephesoft.dcma.da.domain.FieldType fdType : allFdTypes) {
					// Create new document level field
					LOGGER.info("Creating new document level field");
					DocField docLevelField = new DocField();
					docLevelField.setName(fdType.getName());
					docLevelField.setFieldOrderNumber(fdType.getFieldOrderNumber());
					docLevelField.setType(fdType.getDataType().name());
					// Object newValue = getValueForDocField(fdType.getName(), allColumnNames, extractedData);
					// docLevelField.setValue(newValue.toString());

					// Add new document level field to document.
					docLevelFields.add(docLevelField);
					LOGGER.info("New doc level field added : " + docLevelField.getName());
				}
			} else {
				LOGGER.info("No field types could be found for document type :" + eachDocType.getType());				
			}
		}
	}
}
