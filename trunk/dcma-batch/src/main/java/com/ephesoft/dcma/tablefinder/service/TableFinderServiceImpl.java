/********************************************************************************* 
* Ephesoft is a Intelligent Document Capture and Mailroom Automation program 
* developed by Ephesoft, Inc. Copyright (C) 2010-2011 Ephesoft Inc. 
* 
* This program is free software; you can redistribute it and/or modify it under 
* the terms of the GNU Affero General Public License version 3 as published by the 
* Free Software Foundation with the addition of the following permission added 
* to Section 15 as permitted in Section 7(a): FOR ANY PART OF THE COVERED WORK 
* IN WHICH THE COPYRIGHT IS OWNED BY EPHESOFT, EPHESOFT DISCLAIMS THE WARRANTY 
* OF NON INFRINGEMENT OF THIRD PARTY RIGHTS. 
* 
* This program is distributed in the hope that it will be useful, but WITHOUT 
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
* FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more 
* details. 
* 
* You should have received a copy of the GNU Affero General Public License along with 
* this program; if not, see http://www.gnu.org/licenses or write to the Free 
* Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 
* 02110-1301 USA. 
* 
* You can contact Ephesoft, Inc. headquarters at 111 Academy Way, 
* Irvine, CA 92617, USA. or at email address info@ephesoft.com. 
* 
* The interactive user interfaces in modified source and object code versions 
* of this program must display Appropriate Legal Notices, as required under 
* Section 5 of the GNU Affero General Public License version 3. 
* 
* In accordance with Section 7(b) of the GNU Affero General Public License version 3, 
* these Appropriate Legal Notices must retain the display of the "Ephesoft" logo. 
* If the display of the logo is not reasonably feasible for 
* technical reasons, the Appropriate Legal Notices must display the words 
* "Powered by Ephesoft". 
********************************************************************************/ 

/********************************************************************************* 
* Ephesoft is a Intelligent Document Capture and Mailroom Automation program 
* developed by Ephesoft, Inc. Copyright (C) 2010-2011 Ephesoft Inc. 
* 
* This program is free software; you can redistribute it and/or modify it under 
* the terms of the GNU Affero General Public License version 3 as published by the 
* Free Software Foundation with the addition of the following permission added 
* to Section 15 as permitted in Section 7(a): FOR ANY PART OF THE COVERED WORK 
* IN WHICH THE COPYRIGHT IS OWNED BY EPHESOFT, EPHESOFT DISCLAIMS THE WARRANTY 
* OF NON INFRINGEMENT OF THIRD PARTY RIGHTS. 
* 
* This program is distributed in the hope that it will be useful, but WITHOUT 
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
* FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more 
* details. 
* 
* You should have received a copy of the GNU Affero General Public License along with 
* this program; if not, see http://www.gnu.org/licenses or write to the Free 
* Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 
* 02110-1301 USA. 
* 
* You can contact Ephesoft, Inc. headquarters at 111 Academy Way, 
* Irvine, CA 92617, USA. or at email address info@ephesoft.com. 
* 
* The interactive user interfaces in modified source and object code versions 
* of this program must display Appropriate Legal Notices, as required under 
* Section 5 of the GNU Affero General Public License version 3. 
* 
* In accordance with Section 7(b) of the GNU Affero General Public License version 3, 
* these Appropriate Legal Notices must retain the display of the "Ephesoft" logo. 
* If the display of the logo is not reasonably feasible for 
* technical reasons, the Appropriate Legal Notices must display the words 
* "Powered by Ephesoft". 
********************************************************************************/ 

/********************************************************************************* 
* Ephesoft is a Intelligent Document Capture and Mailroom Automation program 
* developed by Ephesoft, Inc. Copyright (C) 2010-2011 Ephesoft Inc. 
* 
* This program is free software; you can redistribute it and/or modify it under 
* the terms of the GNU Affero General Public License version 3 as published by the 
* Free Software Foundation with the addition of the following permission added 
* to Section 15 as permitted in Section 7(a): FOR ANY PART OF THE COVERED WORK 
* IN WHICH THE COPYRIGHT IS OWNED BY EPHESOFT, EPHESOFT DISCLAIMS THE WARRANTY 
* OF NON INFRINGEMENT OF THIRD PARTY RIGHTS. 
* 
* This program is distributed in the hope that it will be useful, but WITHOUT 
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
* FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more 
* details. 
* 
* You should have received a copy of the GNU Affero General Public License along with 
* this program; if not, see http://www.gnu.org/licenses or write to the Free 
* Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 
* 02110-1301 USA. 
* 
* You can contact Ephesoft, Inc. headquarters at 111 Academy Way, 
* Irvine, CA 92617, USA. or at email address info@ephesoft.com. 
* 
* The interactive user interfaces in modified source and object code versions 
* of this program must display Appropriate Legal Notices, as required under 
* Section 5 of the GNU Affero General Public License version 3. 
* 
* In accordance with Section 7(b) of the GNU Affero General Public License version 3, 
* these Appropriate Legal Notices must retain the display of the "Ephesoft" logo. 
* If the display of the logo is not reasonably feasible for 
* technical reasons, the Appropriate Legal Notices must display the words 
* "Powered by Ephesoft". 
********************************************************************************/ 

/********************************************************************************* 
* Ephesoft is a Intelligent Document Capture and Mailroom Automation program 
* developed by Ephesoft, Inc. Copyright (C) 2010-2011 Ephesoft Inc. 
* 
* This program is free software; you can redistribute it and/or modify it under 
* the terms of the GNU Affero General Public License version 3 as published by the 
* Free Software Foundation with the addition of the following permission added 
* to Section 15 as permitted in Section 7(a): FOR ANY PART OF THE COVERED WORK 
* IN WHICH THE COPYRIGHT IS OWNED BY EPHESOFT, EPHESOFT DISCLAIMS THE WARRANTY 
* OF NON INFRINGEMENT OF THIRD PARTY RIGHTS. 
* 
* This program is distributed in the hope that it will be useful, but WITHOUT 
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
* FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more 
* details. 
* 
* You should have received a copy of the GNU Affero General Public License along with 
* this program; if not, see http://www.gnu.org/licenses or write to the Free 
* Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 
* 02110-1301 USA. 
* 
* You can contact Ephesoft, Inc. headquarters at 111 Academy Way, 
* Irvine, CA 92617, USA. or at email address info@ephesoft.com. 
* 
* The interactive user interfaces in modified source and object code versions 
* of this program must display Appropriate Legal Notices, as required under 
* Section 5 of the GNU Affero General Public License version 3. 
* 
* In accordance with Section 7(b) of the GNU Affero General Public License version 3, 
* these Appropriate Legal Notices must retain the display of the "Ephesoft" logo. 
* If the display of the logo is not reasonably feasible for 
* technical reasons, the Appropriate Legal Notices must display the words 
* "Powered by Ephesoft". 
********************************************************************************/ 

/********************************************************************************* 
* Ephesoft is a Intelligent Document Capture and Mailroom Automation program 
* developed by Ephesoft, Inc. Copyright (C) 2010-2011 Ephesoft Inc. 
* 
* This program is free software; you can redistribute it and/or modify it under 
* the terms of the GNU Affero General Public License version 3 as published by the 
* Free Software Foundation with the addition of the following permission added 
* to Section 15 as permitted in Section 7(a): FOR ANY PART OF THE COVERED WORK 
* IN WHICH THE COPYRIGHT IS OWNED BY EPHESOFT, EPHESOFT DISCLAIMS THE WARRANTY 
* OF NON INFRINGEMENT OF THIRD PARTY RIGHTS. 
* 
* This program is distributed in the hope that it will be useful, but WITHOUT 
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
* FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more 
* details. 
* 
* You should have received a copy of the GNU Affero General Public License along with 
* this program; if not, see http://www.gnu.org/licenses or write to the Free 
* Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 
* 02110-1301 USA. 
* 
* You can contact Ephesoft, Inc. headquarters at 111 Academy Way, 
* Irvine, CA 92617, USA. or at email address info@ephesoft.com. 
* 
* The interactive user interfaces in modified source and object code versions 
* of this program must display Appropriate Legal Notices, as required under 
* Section 5 of the GNU Affero General Public License version 3. 
* 
* In accordance with Section 7(b) of the GNU Affero General Public License version 3, 
* these Appropriate Legal Notices must retain the display of the "Ephesoft" logo. 
* If the display of the logo is not reasonably feasible for 
* technical reasons, the Appropriate Legal Notices must display the words 
* "Powered by Ephesoft". 
********************************************************************************/ 

package com.ephesoft.dcma.tablefinder.service;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ephesoft.dcma.batch.schema.Column;
import com.ephesoft.dcma.batch.schema.Coordinates;
import com.ephesoft.dcma.batch.schema.DataTable;
import com.ephesoft.dcma.batch.schema.Field;
import com.ephesoft.dcma.batch.schema.HeaderRow;
import com.ephesoft.dcma.batch.schema.Row;
import com.ephesoft.dcma.batch.schema.DataTable.Rows;
import com.ephesoft.dcma.batch.schema.Field.CoordinatesList;
import com.ephesoft.dcma.batch.schema.HocrPages.HocrPage;
import com.ephesoft.dcma.batch.schema.HocrPages.HocrPage.Spans;
import com.ephesoft.dcma.batch.schema.HocrPages.HocrPage.Spans.Span;
import com.ephesoft.dcma.core.exception.DCMAApplicationException;
import com.ephesoft.dcma.da.domain.TableColumnsInfo;
import com.ephesoft.dcma.da.domain.TableInfo;
import com.ephesoft.dcma.tablefinder.constants.TableExtractionConstants;
import com.ephesoft.dcma.tablefinder.data.DataCarrier;
import com.ephesoft.dcma.tablefinder.data.LineDataCarrier;

public class TableFinderServiceImpl implements TableFinderService {

	/**
	 * LOGGER to print the logging information.
	 */
	private static final Logger LOGGER = LoggerFactory.getLogger(TableFinderServiceImpl.class);

	/**
	 * Confidence score.
	 */
	private String confidenceScore;

	/**
	 * @return the confidenceScore
	 */
	public final String getConfidenceScore() {
		return confidenceScore;
	}

	/**
	 * @param confidenceScore the confidenceScore to set
	 */
	public final void setConfidenceScore(final String confidenceScore) {
		this.confidenceScore = confidenceScore;
	}

	/**
	 * Width of line.
	 */
	private String widthOfLine;

	/**
	 * @return the widthOfLine
	 */
	public String getWidthOfLine() {
		return widthOfLine;
	}

	/**
	 * @param widthOfLine the widthOfLine to set
	 */
	public void setWidthOfLine(String widthOfLine) {
		this.widthOfLine = widthOfLine;
	}

	public DataTable findTableData(final List<TableInfo> inputDataCarrier, final HocrPage hocrPage, final int maxResults)
			throws DCMAApplicationException {

		DataTable dataTable = extractFields(inputDataCarrier, hocrPage, maxResults);
		return dataTable;
	}

	private final DataTable extractFields(final List<TableInfo> tableInfoList, final HocrPage hocrPage, final int maxResults)
			throws DCMAApplicationException {
		DataTable dataTable = readAllDataTables(tableInfoList, hocrPage);
		return dataTable;
	}

	/**
	 * readAllDataTables.
	 * 
	 * @param tableInfoList
	 * @param startDataCarrier
	 * @param lineDataCarrierList
	 * @param dataTableList
	 * @param pageList
	 * @return
	 * @throws DCMAApplicationException
	 */
	private DataTable readAllDataTables(final List<TableInfo> tableInfoList, final HocrPage hocrPage) throws DCMAApplicationException {

		DataTable dataTable = new DataTable();
		DataCarrier startDataCarrier = null;
		for (TableInfo tableInfo : tableInfoList) {
			if (null == tableInfo) {
				LOGGER.info("Table info is null.");
				continue;
			}

			List<LineDataCarrier> lineDataCarrierList = new ArrayList<LineDataCarrier>();

			final String tableName = tableInfo.getName();
			final String startPattern = tableInfo.getStartPattern();
			final String endPattern = tableInfo.getEndPattern();

			if (null == tableName || tableName.isEmpty()) {
				throw new DCMAApplicationException("Table name is null or empty.");
			}

			if (null == startPattern || startPattern.isEmpty()) {
				throw new DCMAApplicationException("Table start pattern is null or empty.");
			}

			if (null == endPattern || endPattern.isEmpty()) {
				throw new DCMAApplicationException("Table end pattern is null or empty.");
			}

			dataTable.setName(tableName);

			HeaderRow headerRow = dataTable.getHeaderRow();
			if (null == headerRow) {
				headerRow = new HeaderRow();
				dataTable.setHeaderRow(headerRow);
			}
			HeaderRow.Columns columnsHeader = headerRow.getColumns();
			if (null == columnsHeader) {
				columnsHeader = new HeaderRow.Columns();
				headerRow.setColumns(columnsHeader);
			}
			List<Column> columnHeaderList = columnsHeader.getColumn();

			List<TableColumnsInfo> tableColumnsInfoList = tableInfo.getTableColumnsInfo();

			if (null == tableColumnsInfoList || tableColumnsInfoList.isEmpty()) {
				LOGGER.error("TableColumnsInfo list is null or empty.");
				continue;
			}

			Rows rows = dataTable.getRows();
			if (null == rows) {
				rows = new Rows();
				dataTable.setRows(rows);
			}

			List<Row> rowList = rows.getRow();

			for (TableColumnsInfo tableColumnsInfo : tableColumnsInfoList) {
				// Create the table header first and then all the columns for the header.
				Column column = new Column();
				String nameOfColumn = tableColumnsInfo.getColumnName();
				column.setName(nameOfColumn);
				columnHeaderList.add(column);
			}

			startDataCarrier = searchAllRowOfTables(hocrPage, lineDataCarrierList, startPattern, endPattern, startDataCarrier);

			startDataCarrier = addDataTablesValues(lineDataCarrierList, tableColumnsInfoList, rowList, startDataCarrier);
		}

		return dataTable;
	}

	/**
	 * addDataTablesValues.
	 * 
	 * @param lineDataCarrierList
	 * @param tableColumnsInfoList
	 * @param rowList
	 * @param startDataCarrier
	 * @return
	 * @throws DCMAApplicationException
	 */
	private DataCarrier addDataTablesValues(final List<LineDataCarrier> lineDataCarrierList,
			final List<TableColumnsInfo> tableColumnsInfoList, final List<Row> rowList, DataCarrier startDataCarrier)
			throws DCMAApplicationException {
		boolean isRowAvaliable = false;
		boolean isRowValidForAllMandatoryColumns = true;
		// int index = 0;
		// for (index = 0; index < tableColumnsInfoList.size(); index++) {
		// alternateFields.add(new ArrayList<Field>());
		// }
		for (LineDataCarrier lineDataCarrier : lineDataCarrierList) {
			String pageID = lineDataCarrier.getPageID();
			String rowData = lineDataCarrier.getLineRowData();
			LOGGER.info("Data of row:" + rowData);
			isRowValidForAllMandatoryColumns = true;
			Row row = new Row();
			Row.Columns columnsRow = row.getColumns();

			if (null == columnsRow) {
				columnsRow = new Row.Columns();
				row.setColumns(columnsRow);
			}

			row.setRowCoordinates(lineDataCarrier.getRowCoordinates());

			List<Column> columnRowList = columnsRow.getColumn();

			isRowAvaliable = false;
			// index = 0;
			for (TableColumnsInfo tableColumnsInfo : tableColumnsInfoList) {

				// Search for all the table row data one by one.
				String patternOfColumnData = tableColumnsInfo.getColumnPattern();
				String betweenLeft = tableColumnsInfo.getBetweenLeft();
				String betweenRight = tableColumnsInfo.getBetweenRight();
				boolean isRequired = tableColumnsInfo.isRequired();

				List<String> outputList = findPattern(rowData, patternOfColumnData);
				Column column = new Column();
				Column.AlternateValues alternateValues = new Column.AlternateValues();
				if (null == outputList || outputList.isEmpty()) {

					column.setName(null);
					column.setValue(null);
					column.setConfidence(0);
					column.setCoordinatesList(null);
					column.setPage(pageID);
					column.setValid(false);
					column.setAlternateValues(alternateValues);
					columnRowList.add(column);
				} else {

					column.setName(null);
					column.setConfidence(100);
					column.setPage(pageID);
					column.setValid(false);
					column.setCoordinatesList(new CoordinatesList());
					column.setAlternateValues(alternateValues);
					columnRowList.add(column);
					isRowAvaliable = true;
					Set<String> alternateValueSet = new HashSet<String>();
					boolean isFound = false;
					outerLoop: for (String output : outputList) {
						if (output == null) {
							if (!isFound) {
								column.setValue(TableExtractionConstants.EMPTY);
							}
							continue;
						}
						if (!isFound) {
							column.setValue(output);
						}

						List<Integer> outputIndexList = getIndexList(output, lineDataCarrier);
						// List<Integer> indexList = lineDataCarrier.getIndexOfSpan(output);
						// String[] foundValArr = output.split(KVFinderConstants.SPACE);

						// List<Integer> indexList = lineDataCarrier.getIndexOfSpan(output);
						if (outputIndexList == null || outputIndexList.isEmpty()) {
							continue;
						}
						// validate the field with left right.
						// Check the validation of data.
						if (!alternateValueSet.contains(output)) {
							alternateValueSet.add(output);
							// for (Integer currentIndex : indexList) {
							for (Integer currentIndex = 0; currentIndex < outputIndexList.size(); currentIndex = currentIndex
									+ output.split(TableExtractionConstants.SPACE).length) {
								int localIndex = currentIndex;
								Field alternateValue = new Field();
								alternateValue.setValue(output);
								alternateValue.setName(null);
								alternateValue.setConfidence(100);
								alternateValue.setPage(pageID);
								CoordinatesList coordinatesList = new CoordinatesList();
								alternateValue.setCoordinatesList(coordinatesList);
								while (localIndex < currentIndex + output.split(TableExtractionConstants.SPACE).length
										&& localIndex < outputIndexList.size()) {
									Span currentSpan = lineDataCarrier.getCurrentSpan(outputIndexList.get(localIndex));
									if (null != currentSpan) {
										Coordinates coordinates = new Coordinates();
										Coordinates hocrCoordinates = currentSpan.getCoordinates();
										if (null != hocrCoordinates) {
											coordinates.setX0(hocrCoordinates.getX0());
											coordinates.setX1(hocrCoordinates.getX1());
											coordinates.setY0(hocrCoordinates.getY0());
											coordinates.setY1(hocrCoordinates.getY1());
											alternateValue.getCoordinatesList().getCoordinates().add(coordinates);
										}
									}
									localIndex++;
								}
								column.getAlternateValues().getAlternateValue().add(alternateValue);
							}
						}
						if (isFound) {
							continue;
						}

						if (betweenLeft != null && !betweenLeft.isEmpty()) {
							if (betweenRight != null && !betweenRight.isEmpty()) {
								for (Integer currentIndex = 0; currentIndex < outputIndexList.size(); currentIndex = currentIndex
										+ output.split(TableExtractionConstants.SPACE).length) {
									Integer localIndex = currentIndex;
									column.getCoordinatesList().getCoordinates().clear();
									while (localIndex < currentIndex + output.split(TableExtractionConstants.SPACE).length
											&& localIndex < outputIndexList.size()) {
										column.setValue(output);
										Span currentSpan = lineDataCarrier.getCurrentSpan(outputIndexList.get(localIndex));
										if (null != currentSpan) {
											setColumnCoordinates(currentSpan, column);
										}
										localIndex++;
									}
									Span leftSpan = lineDataCarrier.getLeftSpan(outputIndexList.get(currentIndex));
									if (null == leftSpan) {
										LOGGER.info("Left Span is null. betweenLeft = " + betweenLeft);
										continue;
									}
									Span rightSpan = lineDataCarrier.getRightSpan(outputIndexList.get(localIndex - 1));
									if (null == rightSpan) {
										LOGGER.info("Right Span is null. betweenRight = " + betweenRight);
										continue;
									}
									DataCarrier leftDataCarrier = findPattern(leftSpan, betweenLeft);
									DataCarrier rightDataCarrier = findPattern(rightSpan, betweenRight);
									if (null != leftDataCarrier && null != rightDataCarrier) {
										column.setValid(true);
										isFound = true;
										continue outerLoop;
										// continue;
										// break outerLoop;
									}
								}
							} else {
								for (Integer currentIndex = 0; currentIndex < outputIndexList.size(); currentIndex = currentIndex
										+ output.split(TableExtractionConstants.SPACE).length) {
									Integer localIndex = currentIndex;
									column.setValue(output);
									column.getCoordinatesList().getCoordinates().clear();
									while (localIndex < currentIndex + output.split(TableExtractionConstants.SPACE).length
											&& localIndex < outputIndexList.size()) {
										column.setValue(output);
										Span currentSpan = lineDataCarrier.getCurrentSpan(outputIndexList.get(localIndex));
										if (null != currentSpan) {
											setColumnCoordinates(currentSpan, column);
										}
										localIndex++;
									}
									Span leftSpan = lineDataCarrier.getLeftSpan(outputIndexList.get(currentIndex));
									if (null == leftSpan) {
										LOGGER.info("Left Span is null. betweenLeft = " + betweenLeft);
										continue;
									}
									DataCarrier leftDataCarrier = findPattern(leftSpan, betweenLeft);
									if (null != leftDataCarrier) {
										column.setValid(true);
										isFound = true;
										continue outerLoop;
										// break outerLoop;
									}
								}
							}
						} else {
							if (betweenRight != null && !betweenRight.isEmpty()) {
								for (Integer currentIndex = 0; currentIndex < outputIndexList.size(); currentIndex = currentIndex
										+ output.split(TableExtractionConstants.SPACE).length) {
									Integer localIndex = currentIndex;
									column.setValue(output);
									column.getCoordinatesList().getCoordinates().clear();
									while (localIndex < currentIndex + output.split(TableExtractionConstants.SPACE).length
											&& localIndex < outputIndexList.size()) {
										column.setValue(output);
										Span currentSpan = lineDataCarrier.getCurrentSpan(outputIndexList.get(localIndex));
										if (null != currentSpan) {
											setColumnCoordinates(currentSpan, column);
										}
										localIndex++;
									}
									Span rightSpan = lineDataCarrier.getRightSpan(outputIndexList.get(localIndex - 1));
									if (null == rightSpan) {
										LOGGER.info("Right Span is null. betweenRight = " + betweenRight);
										continue;
									}
									DataCarrier rightDataCarrier = findPattern(rightSpan, betweenRight);
									if (null != rightDataCarrier) {
										column.setValid(true);
										isFound = true;
										continue outerLoop;
										// break outerLoop;
									}
								}
							} else {
								column.setValue(output);
								column.setValid(true);
								Span currentSpan = lineDataCarrier.getCurrentSpan(0);
								column.getCoordinatesList().getCoordinates().clear();
								if (null != currentSpan) {
									setColumnCoordinates(currentSpan, column);
								}
							}
						}
					}
				}

				// Checking if row contains valid data for every mandatory column
				if (isRequired && !column.isValid()) {
					isRowValidForAllMandatoryColumns = false;
				}
				// index++;
			}

			if (isRowAvaliable && isRowValidForAllMandatoryColumns) {
				LOGGER.info("Row data : " + rowData);
				rowList.add(row);
				startDataCarrier = null;
			}

		}

		// setAlternateValues(rowList, alternateFields);

		return startDataCarrier;
	}

	/**
	 * This method returns the list of indexes of matches of string in a row.
	 * 
	 * @param output {@link String}
	 * @param lineDataCarrier {@link LineDataCarrier}
	 * @return
	 */
	private List<Integer> getIndexList(final String output, final LineDataCarrier lineDataCarrier) {
		String[] foundValArr = output.split(TableExtractionConstants.SPACE);
		List<Coordinates> coordinateList = new ArrayList<Coordinates>();
		List<Integer> outputIndexList = new ArrayList<Integer>();
		if (null != foundValArr && foundValArr.length >= 0) {
			String firstKeyValue = foundValArr[0];
			List<Integer> indexList = lineDataCarrier.getIndexOfSpan(firstKeyValue);
			if (null != indexList) {
				List<Span> spanList = lineDataCarrier.getSpanList();
				for (Integer integer : indexList) {
					List<Coordinates> local = new ArrayList<Coordinates>();
					List<Integer> localIndexList = new ArrayList<Integer>();
					for (int p = 0; p < foundValArr.length; p++) {
						if (integer < spanList.size()) {
							Span span = spanList.get(integer);
							if (null == span) {
								continue;
							}
							String value = span.getValue();
							if (null == value) {
								continue;
							}
							// integer++;
							String fdVal = foundValArr[p];
							if (value.contains(fdVal)) {
								localIndexList.add(integer);
								local.add(span.getCoordinates());
							}
							integer++;
						}
					}
					if (local.size() == foundValArr.length) {
						outputIndexList.addAll(localIndexList);
						coordinateList.addAll(local);
					}
				}
			}
		}
		return outputIndexList;
	}

	/**
	 * This method adds the coordinates of current span to the coordinates list of a column.
	 * 
	 * @param currentSpan
	 * @param column
	 */
	private void setColumnCoordinates(final Span currentSpan, final Column column) {
		if (null != currentSpan) {
			Coordinates coordinates = new Coordinates();
			Coordinates hocrCoordinates = currentSpan.getCoordinates();
			if (null != hocrCoordinates) {
				coordinates.setX0(hocrCoordinates.getX0());
				coordinates.setX1(hocrCoordinates.getX1());
				coordinates.setY0(hocrCoordinates.getY0());
				coordinates.setY1(hocrCoordinates.getY1());
				// column.getCoordinatesList().getCoordinates().clear();
				column.getCoordinatesList().getCoordinates().add(coordinates);
				// column.setCoordinates(coordinates);
			}
		}
	}

	/**
	 * searchAllRowOfTables.
	 * 
	 * @param pageList
	 * @param lineDataCarrierList
	 * @param startDataCarrier
	 * @param startPattern
	 * @param endPattern
	 * @return
	 * @throws DCMAApplicationException
	 * 
	 */
	private DataCarrier searchAllRowOfTables(final HocrPage hocrPage, final List<LineDataCarrier> lineDataCarrierList,
			final String startPattern, final String endPattern, DataCarrier startDataCarrier) throws DCMAApplicationException {

		String errMsg = null;
		pageLabel: {

			String pageID = hocrPage.getPageID();

			LOGGER.info("HocrPage page ID : " + pageID);
			final Spans spans = hocrPage.getSpans();

			LineDataCarrier lineDataCarrier = new LineDataCarrier(pageID);
			lineDataCarrierList.add(lineDataCarrier);

			if (null != spans) {

				List<Span> linkedList = getSortedList(spans);
				if (null == linkedList || linkedList.isEmpty()) {
					LOGGER.info("Return linked list is null for the page id = " + pageID);
					return null;
				}
				ListIterator<Span> listItr = linkedList.listIterator();
				if (null == listItr) {
					LOGGER.info("Return list iterator is null for the page id = " + pageID);
					return null;
				}
				// int nextIndex = -1;

				if (startDataCarrier == null) {
					while (listItr.hasNext()) {
						final Span span = listItr.next();
						try {
							startDataCarrier = findPattern(span, startPattern);
							if (null != startDataCarrier) {
								// nextIndex = listItr.nextIndex();
								LOGGER.info("Start pattern found for table where start pattern : " + startPattern);
								break;
							} else {
								LOGGER.info("No start pattern found for table where start pattern : " + startPattern);

							}
						} catch (Exception e) {
							errMsg = e.getMessage();
							LOGGER.error(errMsg, e);
						}
					}
				}
				if (startDataCarrier != null) {
					// if (nextIndex != -1) {
					// listItr = linkedList.listIterator(nextIndex);
					// }
					while (listItr.hasNext()) {
						final Span span = listItr.next();
						DataCarrier endDataCarrier = findPattern(span, endPattern);
						if (null != endDataCarrier) {
							LOGGER.info("End pattern found for table where end pattern : " + endPattern);
							// continue documentLabel;
							break pageLabel;
						} else {
							// TODO add code to search table content.
							// get the line array as word by word
							// fetch from db all the columns and patterns.
							// validate using left and right pattern.
							List<Span> spanList = lineDataCarrier.getSpanList();
							if (spanList.isEmpty()) {
								spanList.add(span);
							} else {
								Span lastSpan = spanList.get(spanList.size() - 1);
								int compare = lastSpan.getCoordinates().getY1().intValue() - span.getCoordinates().getY1().intValue();
								int defaultValue = 20;
								try {
									defaultValue = Integer.parseInt(getWidthOfLine());
								} catch (NumberFormatException nfe) {
									LOGGER.error(nfe.getMessage(), nfe);
									defaultValue = 20;
								}
								if (compare >= -defaultValue && compare <= defaultValue) {
									spanList.add(span);
								} else {
									lineDataCarrier = new LineDataCarrier(pageID);
									lineDataCarrierList.add(lineDataCarrier);
									spanList = lineDataCarrier.getSpanList();
									spanList.add(span);
								}
							}
						}
					}
				}
			}
		}

		return startDataCarrier;
	}

	/**
	 * Method is responsible for finding the patterns and returned the found data List.
	 * 
	 * @param span Span
	 * @param patternStr String
	 * @return DataCarrier
	 * @throws DCMAApplicationException Check for all the input parameters and find the pattern.
	 */
	private final DataCarrier findPattern(final Span span, final String patternStr) throws DCMAApplicationException {

		String errMsg = null;
		DataCarrier dataCarrier = null;
		final CharSequence inputStr = span.getValue();
		boolean isFound = false;
		if (null == inputStr || TableExtractionConstants.EMPTY.equals(inputStr)) {

			errMsg = "Invalid input character sequence.";
			// throw new DCMAApplicationException(errMsg);
			LOGGER.info(errMsg);

		} else {

			if (null == patternStr || TableExtractionConstants.EMPTY.equals(patternStr)) {
				errMsg = "Invalid input pattern sequence.";
				throw new DCMAApplicationException(errMsg);
			}

			// Compile and use regular
			// expression
			final Pattern pattern = Pattern.compile(patternStr);
			final Matcher matcher = pattern.matcher(inputStr);
			// boolean matchFound = matcher.find();
			while (matcher.find()) {
				// Get all groups for this match
				for (int i = 0; i <= matcher.groupCount(); i++) {
					final String groupStr = matcher.group(i);
					isFound = false;
					if (patternStr.contains(TableExtractionConstants.NOT_SPACE)) {
						if (groupStr.contains(TableExtractionConstants.FULL_STOP)) {
							isFound = true;
						}
					} else {
						isFound = true;
					}

					if (isFound) {
						int confidenceInt = 100;
						try {
							confidenceInt = Integer.parseInt(getConfidenceScore());
						} catch (NumberFormatException nfe) {
							LOGGER.error(nfe.getMessage(), nfe);
						}
						final float confidence = (groupStr.length() * confidenceInt) / inputStr.length();
						dataCarrier = new DataCarrier(span, confidence, groupStr);
						LOGGER.info(groupStr);
					}
				}
			}
		}

		return dataCarrier;
	}

	/**
	 * Method is responsible for finding the patterns and returned the found data List.
	 * 
	 * @param span Span
	 * @param patternStr String
	 * @return DataCarrier
	 * @throws DCMAApplicationException Check for all the input parameters and find the pattern.
	 */
	private final List<String> findPattern(final String value, final String patternStr) throws DCMAApplicationException {

		String errMsg = null;
		List<String> outputList = null;
		final CharSequence inputStr = value;
		boolean isFound = false;
		if (null == inputStr || TableExtractionConstants.EMPTY.equals(inputStr)) {

			errMsg = "Invalid input character sequence.";
			// throw new DCMAApplicationException(errMsg);
			LOGGER.info(errMsg);

		} else {

			if (null == patternStr || TableExtractionConstants.EMPTY.equals(patternStr)) {
				errMsg = "Invalid input pattern sequence.";
				throw new DCMAApplicationException(errMsg);
			}

			// Compile and use regular
			// expression
			final Pattern pattern = Pattern.compile(patternStr);
			final Matcher matcher = pattern.matcher(inputStr);
			// boolean matchFound = matcher.find();
			while (matcher.find()) {
				// Get all groups for this match
				for (int i = 0; i <= matcher.groupCount(); i++) {
					final String groupStr = matcher.group(i);
					isFound = false;
					if (groupStr != null) {
						if (patternStr.contains(TableExtractionConstants.NOT_SPACE)) {
							if (groupStr.contains(TableExtractionConstants.FULL_STOP)) {
								isFound = true;
							}
						} else {
							isFound = true;
						}
					}

					if (isFound) {
						if (null == outputList) {
							outputList = new ArrayList<String>();
						}

						outputList.add(groupStr);
						LOGGER.info(groupStr);
					}
				}
			}
		}

		return outputList;
	}

	private List<Span> getSortedList(final Spans spans) {

		final List<Span> spanList = spans.getSpan();

		int width = 20;
		try {
			width = Integer.parseInt(getWidthOfLine());
		} catch (NumberFormatException nfe) {
			LOGGER.error(nfe.getMessage(), nfe);
			width = 20;
		}
		final int defaultValue = width;
		final Set<Span> set = new TreeSet<Span>(new Comparator<Span>() {

			public int compare(final Span firstSpan, final Span secSpan) {
				BigInteger s1Y1 = firstSpan.getCoordinates().getY1();
				BigInteger s2Y1 = secSpan.getCoordinates().getY1();
				int returnValue = 0;
				int compare = s1Y1.intValue() - s2Y1.intValue();
				if (compare >= -defaultValue && compare <= defaultValue) {
					BigInteger s1X1 = firstSpan.getCoordinates().getX1();
					BigInteger s2X1 = secSpan.getCoordinates().getX1();
					returnValue = s1X1.compareTo(s2X1);
				} else {
					returnValue = s1Y1.compareTo(s2Y1);
				}
				return returnValue;
			}
		});

		set.addAll(spanList);
		if (set != null) {
			for (Span span : set) {
				LOGGER.info(span.getValue());
			}
		}
		final List<Span> linkedList = new LinkedList<Span>();
		linkedList.addAll(set);

		// TODO add the clear method to remove all elements of set since it not required after adding it to linked list.
		// set.clear();

		return linkedList;

	}
}
